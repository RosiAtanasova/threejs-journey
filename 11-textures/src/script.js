import './style.css'
import * as THREE from 'three'
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'

// Textures

// === loadingManager ===

// if you have multiple images to load use 'loadingManager'
// there are events onStart, onLoad, onProgress, and onError

const loadingManager = new THREE.LoadingManager();
loadingManager.onStart = () => 
{
    // console.log("Loading started")
}
loadingManager.onLoad = () => 
{
    // console.log("Loading finished")
}
loadingManager.onProgress = () => 
{
    // console.log("Loading progress")
}
loadingManager.onError = () => 
{
    // console.log("Loading error")
}

// === Load Single image ===
// const textureLoader = new THREE.TextureLoader('./textures/door/color.jpg');

const textureLoader = new THREE.TextureLoader(loadingManager);

const colorTexture = textureLoader.load('./textures/door/color.jpg');

//black: fully transparent; white: fully visible) ; used to erase sth 
const alphaTexture = textureLoader.load('./textures/door/alpha.jpg');

//The height texture is a grayscale image that will move the vertices to create some relief. 
//You'll need to add subdivision if you want to see it.
const heightTexture = textureLoader.load('./textures/door/height.jpg');

//The normal texture will add small details. It won't move the vertices, but it will lure the 
//light into thinking that the face is oriented differently. 
//Normal textures are very useful to add details with good performance 
//because you don't need to subdivide the geometry.
const normalTexture = textureLoader.load('./textures/door/normal.jpg');

//The ambient occlusion texture is a grayscale image that will fake shadow in the surface's crevices. 
//While it's not physically accurate, it certainly helps to create contrast.
const ambientOcclusionTexture = textureLoader.load('./textures/door/ambientOcclusion.jpg');

//How much the material is like a metal. Non-metallic materials such as wood or stone use 0.0, 
//metallic use 1.0, with nothing (usually) in between. 
//Default is 0.0. A value between 0.0 and 1.0 could be used for a rusty metal look. 
//If metalnessMap is also provided, both values are multiplied
const metalnessTexture = textureLoader.load('./textures/door/metalness.jpg');

//The roughness is a grayscale image that comes with metalness, and that will specify 
//which part is rough (white) and which part is smooth (black). 
//This information will help to dissipate the light. 
//A carpet is very rugged, and you won't see the light reflection on it, while the water's surface 
//is very smooth, and you can see the light reflecting on it. 
//Here, the wood is uniform because there is a clear coat on it.
const roughnessTexture = textureLoader.load('./textures/door/roughness.jpg');

/**
 * --- Alpha ---
    The alpha texture is a grayscale image where white will be visible, 
    and black won't. 
 */

/**
 * UV unwrapping
 * 
 * While it is quite logical how to place a texture on a cube, 
 * things can be a little trickier for other geometries.
   Try to replace your BoxGeometry with other geometries:

   // Or
    const geometry = new THREE.SphereGeometry(1, 32, 32)

    // Or
    const geometry = new THREE.ConeGeometry(1, 1, 32)

    As you can see, the texture is being stretched or squeezed in different ways to cover the geometry.

    That is called UV unwrapping. You can imagine that like unwrapping an origami or a candy wrap to make it flat. 
    Each vertex will have a 2D coordinate on a flat (usually square) plane.

   You can actually see those UV 2D coordinates in the 
   geometry.attributes.uv property:

   Those UV coordinates are generated by Three.js when you use the primitives. 
   If you create your own geometry and want to apply a texture to it, 
   you'll have to specify the UV coordinates.
   If you are making the geometry using a 3D software, 
   you'll also have to do the UV unwrapping

   Don't worry; most 3D software also has auto unwrapping that should do the trick.

   You can repeat the texture using the repeat 
   property, which is a Vector2, meaning that it has x and y properties.
 
   
   colorTexture.repeat.x = 2
   colorTexture.repeat.y = 3

   Texture is not repeating, but it is smaller, and the last pixel seems stretched.
   That is due to the texture not being set up to repeat itself by default. 
   To change that, you have to update the wrapS and wrapT properties 
   using the THREE.RepeatWrapping constant.

   colorTexture.wrapS = THREE.RepeatWrapping
   colorTexture.wrapT = THREE.RepeatWrapping

   colorTexture.wrapS = THREE.RepeatWrapping
   colorTexture.wrapT = THREE.RepeatWrapping

   colorTexture.wrapS = THREE.MirroredRepeatWrapping
   colorTexture.wrapT = THREE.MirroredRepeatWrapping

   Offset
   You can offset the texture using the offset property that is also 
   a Vector2 with x and y properties. Changing these will simply offset 
   the UV coordinates:

   colorTexture.offset.x = 0.5
   colorTexture.offset.y = 0.5

   Rotation
   You can rotate the texture using the rotation property, 
   which is a simple number corresponding to the angle in radians:
   colorTexture.rotation = Math.PI * 0.25

    If you want to change the pivot of that rotation, you can do it 
    using the center property which is also a Vector2:

    colorTexture.rotation = Math.PI * 0.25
    colorTexture.center.x = 0.5
    colorTexture.center.y = 0.5

    Mipmapping (or "mip mapping" with a space) is a technique that consists of creating half a smaller version of a texture again and again until you get a 1x1 texture. All those texture variations are sent to the GPU, and the GPU will choose the most appropriate version of the texture.

    Three.js and the GPU already handle all of this, and you can just set what filter algorithm to use. There are two types of filter algorithms: the minification filter and the magnification filter.

    Minification filter
    The minification filter happens when the pixels of texture are smaller than the pixels of the render. In other words, the texture is too big for the surface, it covers.

    You can change the minification filter of the texture using the minFilter property.

    There are 6 possible values:

    THREE.NearestFilter
    THREE.LinearFilter
    THREE.NearestMipmapNearestFilter
    THREE.NearestMipmapLinearFilter
    THREE.LinearMipmapNearestFilter
    THREE.LinearMipmapLinearFilter
    The default is THREE.LinearMipmapLinearFilter. 
    If you are not satisfied with how your texture looks, 
    you should try the other filters.

    We won't see each one, but we will test the THREE.NearestFilter, 
    which has a very different result:


    colorTexture.minFilter = THREE.NearestFilter

    Magnification filter
    The magnification filter works just like the minification filter, but when the pixels of the texture are bigger than the render's pixels. In other words, the texture too small for the surface it covers.

    You can see the result using the checkerboard-8x8.png texture also located in the static/textures/ folder:
    const colorTexture = textureLoader.load('/textures/checkerboard-8x8.png')

    The texture gets all blurry because it's a very small texture on a very large surface.

    While you might think this looks awful, it is probably for the best. If the effect isn't too exaggerated, the user will probably not even notice it.

    You can change the magnification filter of the texture using the magFilter property.

    There are only two possible values:

    THREE.NearestFilter
    THREE.LinearFilter
    The default is THREE.LinearFilter.

    If you test the THREE.NearestFilter, you'll see that the base image is preserved, and you get a pixelated texture:
    colorTexture.magFilter = THREE.NearestFilter

    One final word about all those filters is that THREE.NearestFilter is cheaper than the other ones, and you should get better performances when using it.

    Only use the mipmaps for the minFilter property. If you are using the THREE.NearestFilter, you don't need the mipmaps, and you can deactivate them with colorTexture.generateMipmaps = false:
    colorTexture.generateMipmaps = false
    colorTexture.minFilter = THREE.NearestFilter
    That will slightly offload the GPU.

    Three.js will produce a half smaller version of the texture repeatedly until it gets a 1x1 texture. Because of that, your texture width and height must be a power of 2. That is mandatory so that Three.js can divide the size of the texture by 2.

    Some examples: 512x512, 1024x1024 or 512x2048

    512, 1024 and 2048 can be divided by 2 until it reaches 1.

    If you are using a texture with a width or height different than a power of 2 value, 
    Three.js will try to stretch it to the closest power of 2 number, which can have visually poor results, and you'll also get a warning in the console.
   
   */
    //By default, the texture isn't repeated and the last px is stretched
    // colorTexture.repeat.x = 2
    // colorTexture.repeat.y = 3

    //We can change that with THREE.RepeatWrapping on wrapS and wrapT
    // colorTexture.wrapS = THREE.RepeatWrapping
    // colorTexture.wrapT = THREE.RepeatWrapping

    // colorTexture.offset.x = 0.5;
    // colorTexture.offset.y = 0.5;

    // colorTexture.rotation = Math.PI /4
    // colorTexture.center.x = 0.5
    // colorTexture.center.y = 0.5

    //Mipmapping is a technic that consist of creating half a smaller
    //version of a texture again and again until we got 1x1 texture
    //Those texture variations are sent to GPU and GPU
    //will choose the most appropriate version of the texture

/**
 *  Minification filter
 * -------------------------------------
 * 
    The minification filter happens when :
    the texture is too big for the surface, it covers.

    You can change the minification filter of the texture using the minFilter property.

    There are 6 possible values:

        THREE.NearestFilter
        THREE.LinearFilter
        THREE.NearestMipmapNearestFilter
        THREE.NearestMipmapLinearFilter
        THREE.LinearMipmapNearestFilter
        THREE.LinearMipmapLinearFilter

    The default is THREE.LinearMipmapLinearFilter. 
    If you are not satisfied with how your texture looks, you should try the other filters.

    If you're using a device with a pixel ratio above one, you won't see much of a difference. 
    If not, place the camera where this face is 
    almost hidden, and you should get more details and strange artifacts.
 */
   
    //

    /*
    Magnification filter
    --------------------------------------

    ==========================================================
    = The magnification filter -  when the texture too small 
    = for the surface it covers.
    ===========================================================

    There are only two possible values:
    ============================================
    =  THREE.NearestFilter
    =  THREE.LinearFilter
    ============================================

    The default is THREE.LinearFilter.

    If you test the THREE.NearestFilter, you get a pixelated texture:

    ========================================================

    = THREE.NearestFilter is cheaper than the other ones, 
    = and you should get better performances when using it.

    =======================================================

    Only use the mipmaps for the minFilter property. 
    If you are using the THREE.NearestFilter, you don't need the mipmaps, 
    and you can deactivate them with 

    colorTexture.generateMipmaps = false:
      
    colorTexture.generateMipmaps = false
    colorTexture.minFilter = THREE.NearestFilter
*/
    //default LinearFilter
    colorTexture.generateMipmaps = false; // if we use minFilter = THREE.NearestFilter
    colorTexture.minFilter = THREE.NearestFilter 
    colorTexture.magFilter = THREE.NearestFilter 
// Canvas
const canvas = document.querySelector('canvas.webgl')


// Scene
const scene = new THREE.Scene()


// Object
const geometry = new THREE.BoxGeometry(1, 1, 1)
console.log(geometry.attributes.uv)

// Test color.jpg texture with different geomtries to see the streching
// const geometry = new THREE.SphereGeometry(1, 32, 32)
// const geometry = new THREE.ConeGeometry(1, 1, 32)
// const geometry = new THREE.TorusGeometry(1, 0.35, 32, 100)

//Set texture to the material
const material = new THREE.MeshBasicMaterial({ map : colorTexture })
const mesh = new THREE.Mesh(geometry, material)
scene.add(mesh)

/**
 * Sizes
 */
const sizes = {
    width: window.innerWidth,
    height: window.innerHeight
}

window.addEventListener('resize', () =>
{
    // Update sizes
    sizes.width = window.innerWidth
    sizes.height = window.innerHeight

    // Update camera
    camera.aspect = sizes.width / sizes.height
    camera.updateProjectionMatrix()

    // Update renderer
    renderer.setSize(sizes.width, sizes.height)
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
})

/**
 * Camera
 */
// Base camera
const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height, 0.1, 100)
camera.position.x = 1
camera.position.y = 1
camera.position.z = 1
scene.add(camera)

// Controls
const controls = new OrbitControls(camera, canvas)
controls.enableDamping = true

/**
 * Renderer
 */
const renderer = new THREE.WebGLRenderer({
    canvas: canvas
})
renderer.setSize(sizes.width, sizes.height)
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))

/**
 * Animate
 */
const clock = new THREE.Clock()

const tick = () =>
{
    const elapsedTime = clock.getElapsedTime()

    // Update controls
    controls.update()

    // Render
    renderer.render(scene, camera)

    // Call tick again on the next frame
    window.requestAnimationFrame(tick)
}

tick()